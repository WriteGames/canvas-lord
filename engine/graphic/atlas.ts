import type { AtlasAsset, ImageAsset } from '../core/asset-manager.js';
import type { Ctx } from '../util/canvas.js';
import { Draw } from '../util/draw.js';
import type { Animation, AnimFrameKey } from './animation.js';

export interface AtlasFrame {
	texture: ImageAsset;
	filename: string;
	rotated: boolean;
	trimmed: boolean;
	sourceSize: { w: number; h: number };
	spriteSourceSize: { x: number; y: number; w: number; h: number };
	frame: { x: number; y: number; w: number; h: number };
	anchor?: { x: number; y: number };
}

type FrameData = Record<AnimFrameKey, AtlasFrame>;

export const createAnim = (tag: string, length: number): Animation => ({
	name: tag,
	frames: Array.from({ length }, (_, i) => `${tag}-${i}`),
	frameRate: 5,
	loop: true,
});

export class Atlas {
	frame = -1;
	frameId = 0;

	anims: Record<string, Animation>;
	frameData: FrameData;

	private constructor(
		anims: Record<string, Animation>,
		frameData: FrameData,
	) {
		const animsArr = Object.values(anims);
		if (animsArr.length === 0) throw new Error('no animations supplied');

		this.anims = anims;
		this.frameData = frameData;
	}

	static fromTexturePacker(data: AtlasAsset): Atlas {
		if (!data.loaded) throw new Error();

		const { fileName } = data;
		const filePath = fileName.replace(/\/(?:.(?!\/))+$/g, '');

		// TODO(bret): image is a metadata field generated by Aseprite
		const textureFileName = [filePath, data.data.meta.image].join('/');
		const texture = data.manager.getImage(textureFileName);

		// TODO(bret): tags is a metadata field generated by Aseprite
		const tags = data.data.meta.frameTags ?? [];

		const anims = Object.fromEntries(
			tags.map(({ name, to, from }) => [
				name,
				createAnim(name, to - from + 1),
			]),
		);

		let frameData: FrameData;
		if ('frames' in data.data) {
			const { frames: _frames } = data.data;

			// TODO(bret): support array
			if (Array.isArray(_frames)) throw new Error('not yet supported');

			const frames = Object.entries(_frames).map(([k, v]) => {
				const frame: AtlasFrame = {
					texture,
					...v,
				};
				return [k, frame] as const;
			});
			frameData = Object.fromEntries(frames);
		} else {
			throw new Error('not yet supported');
		}

		return new Atlas(anims, frameData);
	}
}

export function renderAtlas(
	ctx: Ctx,
	asset: ImageAsset,
	frame: AtlasFrame,
	x = 0,
	y = 0,
): void {
	const { anchor = { x: 0, y: 0 } } = frame;

	const originX = anchor.x * frame.frame.w;
	const originY = anchor.y * frame.frame.h;

	let drawX = x + originX;
	let drawY = y + originY;
	if (frame.trimmed) {
		drawX += frame.spriteSourceSize.x;
		drawY += frame.spriteSourceSize.y;
	}

	const sourceX = frame.frame.x;
	const sourceY = frame.frame.y;
	const w = frame.frame.w;
	const h = frame.frame.h;

	Draw.image(
		ctx,
		{
			imageSrc: asset.image,
			originX,
			originY,
		},
		drawX,
		drawY,
		sourceX,
		sourceY,
		w,
		h,
	);

	if (true as boolean) {
		Draw.rect(
			ctx,
			{
				color: 'lime',
				type: 'stroke',
			},
			x,
			y,
			frame.sourceSize.w,
			frame.sourceSize.h,
		);

		Draw.rect(
			ctx,
			{
				color: 'red',
				type: 'stroke',
			},
			drawX - originX,
			drawY - originY,
			w,
			h,
		);
	}
}
