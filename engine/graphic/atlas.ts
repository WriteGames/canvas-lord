import type { AtlasAsset, ImageAsset } from '../core/asset-manager.js';
import { Vec2 } from '../math/index.js';
import type { Camera } from '../util/camera.js';
import type { Ctx } from '../util/canvas.js';
import { Draw } from '../util/draw.js';
import type { Animation } from './animation.js';
import { Graphic } from './graphic.js';

export interface AtlasFrame {
	texture: ImageAsset;
	filename: string;
	rotated: boolean;
	trimmed: boolean;
	// the full size of the original frame
	sourceSize: { w: number; h: number };
	// the cropped rect within the original image
	spriteSourceSize: { x: number; y: number; w: number; h: number };
	// the rect we want to use
	frame: { x: number; y: number; w: number; h: number };
	// the rotation point
	anchor: { x: number; y: number };
}

type FrameData = Record<string, AtlasFrame>;

export const createAnim = (tag: string, length: number): Animation => ({
	name: tag,
	frames: Array.from({ length }, (_, i) => `${tag}-${i}`),
	frameRate: 5,
	loop: true,
});

// TODO(bret): implements ISpriteLike
export class Atlas extends Graphic {
	frame = -1;
	frameId = 0;

	curAnim?: Animation;
	anims: Record<string, Animation>;
	frameData: FrameData;

	private constructor(
		anims: Record<string, Animation>,
		frameData: FrameData,
	) {
		super();

		this.frameData = frameData;

		const animsArr = Object.values(anims);
		if (animsArr.length === 0) throw new Error('no animations supplied');

		this.anims = anims;

		this.curAnim = animsArr[0];
	}

	static fromTexturePacker(data: AtlasAsset): Atlas {
		if (!data.loaded) throw new Error();

		const { fileName } = data;
		const filePath = fileName.replace(/\/(?:.(?!\/))+$/g, '');

		// TODO(bret): image is a metadata field generated by Aseprite
		const textureFileName = [filePath, data.data.meta.image].join('/');
		const texture = data.manager.getImage(textureFileName);

		// TODO(bret): tags is a metadata field generated by Aseprite
		const tags = data.data.meta.frameTags ?? [];

		const anims = Object.fromEntries(
			tags.map(({ name, to, from }) => [
				name,
				createAnim(name, to - from + 1),
			]),
		);

		let frameData: FrameData;
		if ('frames' in data.data) {
			const { frames: _frames } = data.data;

			// TODO(bret): support array
			if (Array.isArray(_frames)) throw new Error('not yet supported');

			const frames = Object.entries(_frames).map(([k, v]) => {
				const frame: AtlasFrame = {
					texture,
					...v,
				};
				return [k, frame] as const;
			});
			frameData = Object.fromEntries(frames);
		} else {
			throw new Error('not yet supported');
		}

		return new Atlas(anims, frameData);
	}

	update(): void {
		++this.frame;

		this.frameId = Math.floor(this.frame / 5);
	}

	render(ctx: Ctx, camera: Camera = Vec2.zero): void {
		if (!this.visible) return;

		// DECIDE(bret): What do we want to do here? How do we get to this case?
		if (!this.curAnim) return;

		const frameData = this.frameData;
		const { frames } = this.curAnim;
		const curFilename = frames[this.frameId % frames.length];
		// if (Array.isArray(frameData)) {
		// 	frame = frameData.find(
		// 		({ filename }) => filename === curFilename,
		// 	);
		// } else {
		const frame = frameData[curFilename];
		// }

		if ((frame as AtlasFrame | undefined) === undefined) return;

		let x = this.x - camera.x * this.scrollX;
		let y = this.y - camera.y * this.scrollY;
		if (this.relative) {
			x += this.parent?.x ?? 0;
			y += this.parent?.y ?? 0;
		}

		renderAtlas(ctx, frame.texture, frame, x, y);
	}
}

export function renderAtlas(
	ctx: Ctx,
	asset: ImageAsset,
	frame: AtlasFrame,
	x = 0,
	y = 0,
): void {
	const { anchor = { x: 0, y: 0 } } = frame;

	const originX = anchor.x * frame.frame.w;
	const originY = anchor.y * frame.frame.h;

	let drawX = x + originX;
	let drawY = y + originY;
	if (frame.trimmed) {
		drawX += frame.spriteSourceSize.x;
		drawY += frame.spriteSourceSize.y;
	}

	const sourceX = frame.frame.x;
	const sourceY = frame.frame.y;
	const w = frame.frame.w;
	const h = frame.frame.h;

	Draw.image(
		ctx,
		{
			imageSrc: asset.image,
			originX,
			originY,
		},
		drawX,
		drawY,
		sourceX,
		sourceY,
		w,
		h,
	);

	if (true as boolean) {
		Draw.rect(
			ctx,
			{
				color: 'lime',
				type: 'stroke',
			},
			x,
			y,
			frame.sourceSize.w,
			frame.sourceSize.h,
		);

		Draw.rect(
			ctx,
			{
				color: 'red',
				type: 'stroke',
			},
			drawX - originX,
			drawY - originY,
			w,
			h,
		);
	}
}
